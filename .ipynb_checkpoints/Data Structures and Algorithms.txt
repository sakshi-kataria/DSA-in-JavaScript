{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "##### Algorithm\n",
    "Outline of step that program has to follow.\n",
    "##### Program\n",
    "Implementaion of algorithm.\n",
    "#### Data Structure \n",
    "The way of organizing data so that it can be effectively used by program.\n",
    "Good Algorithm is effecient algorithm\n",
    "#### Efficient algorithm\n",
    "(1) Small Running Time\n",
    "(2) Small Space Used\n",
    "\n",
    "We also have interest in \n",
    "increase in input size will also increase in running time & space.\n",
    "\n",
    "For Analyze running time of algorithm, we will develop **general methology** like:\n",
    "* Use **high level description** of algorithm instead of testing one of the implementation.\n",
    "* Takes into account **all possible input**\n",
    "* Independed of platform means no hardware and software dependencies.\n",
    "\n",
    "### Pseudo-Code\n",
    "It is a mixture of natural language and some of high level programing concept that describe main idea behind a generic implemenation of data structure or algorithm\n",
    "\n",
    "`eg: Algorithm arrayMax(A,n)\n",
    "    Input: An array that store n elements\n",
    "    Output: Maximum element in A\n",
    "    CurrentMax <- A[0]\n",
    "    for i <- 1 to n-1 do\n",
    "    if currentMax < A[i] then currentMax <- A[i]\n",
    "    return currentMax`\n",
    "    \n",
    "It is structural but less formal than programming language\n",
    "\n",
    "**Decelaration** Algorithm name(param1,param2).\n",
    "\n",
    "**Programming Constructor** :\n",
    "* if..then..else\n",
    "* while..do\n",
    "* repeat..until\n",
    "* for.. do\n",
    "* A[i], A[i,j]\n",
    "\n",
    "**Method**:\n",
    "* Call Object Method(args)\n",
    "* return: return value\n",
    "\n",
    "<img src=\"algo1.png\",width=500,height=500>\n",
    "\n",
    "## Insertion Sort\n",
    "\n",
    "#### Strategy:\n",
    "* start empty handed\n",
    "* Insert a card in the right position of already sorted hand\n",
    "* Continue untillall card inserted/sorted\n",
    "\n",
    "*Pseduo Code*:\n",
    "Input: A[1..n] array of integer\n",
    "Output: A should be like A[1]<=A[2]<=A[3]\n",
    "\n",
    "<html>\n",
    "    <body>\n",
    "        <table>\n",
    "        <tr>\n",
    "            <td>3</td>\n",
    "            <td>4</td>\n",
    "            <td>6</td>\n",
    "            <td>8</td>\n",
    "            <td>9</td>\n",
    "            <td style='color:red'>7</td>\n",
    "            <td style='color:red'>2</td>\n",
    "            <td style='color:red'>5</td>\n",
    "            <td style='color:red'>1</td>\n",
    "        </tr>\n",
    "        </table>\n",
    "    </body>\n",
    "</html>\n",
    "\n",
    "* 3 <- **1**\n",
    "* 9 <- **i**\n",
    "* 7 <- **j**\n",
    "* 1 <- **n**\n",
    "\n",
    "` for j <- 2 to n do\n",
    "     key <- A[j]\n",
    "     i <- j-1\n",
    "     while i > 0 and A[i] > key\n",
    "      do A[i+1] <- A[i]\n",
    "         i--\n",
    "     A[i+1] <- key`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[ 3, 4, 6, 8, 9, 7, 2, 5, 1 ]\n",
      "[ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "undefined"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "var arrForSorting=[3,4,6,8,9,7,2,5,1];\n",
    "function InsertionSort(arr){\n",
    "    for(var i=1;i<arr.length;i++){\n",
    "        var key=arr[i];\n",
    "        var j=i-1;\n",
    "        for(;j>=0 && arr[j]>key;j--){\n",
    "            arr[j+1]=arr[j];\n",
    "        }\n",
    "        arr[j+1]=key;\n",
    "    }\n",
    "}\n",
    "console.log(arrForSorting);\n",
    "InsertionSort(arrForSorting);\n",
    "console.log(arrForSorting);"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<img src=\"Analysis of Insertion Sort.png\",width=700,height=200>\n",
    "\n",
    "tj -> Reflects the count no of time, I have to shift element in right when I am inserting the jth card.\n",
    "\n",
    "### Best/ Worst/ Average Case\n",
    "\n",
    "**Best Case**: Elements already sorted; tj=1( I will check last element if it is less than it will reain same), running time=f(n), i.e. linear time.\n",
    "\n",
    "**Worst Case**: Elements are sorted in inverse order, tj=j, running time=f(n^2); quadratic time.\n",
    "\n",
    "**Average Case**: tj=j/2, running time=f(n^2); quadratic time.\n",
    "\n",
    "<img src=\"ForSpecificSizeInsertionSorting.png\",width=700,height=100>\n",
    "\n",
    "<img src=\"ForAllSizeInsertionSorting.png\",width=700,height=100>\n",
    "\n",
    "Worst case is usually used, it defined upper bound and Average case is as bad as worst case as we see in insertion sorting and Avg case is difficult to compute.\n",
    "\n",
    "## Asymptotatic Analysis:\n",
    "\n",
    "    * Goal is to simplify analysis of running time by getting rid of details which may be affected by specific implemenation and hardware\n",
    "    like 3n^2= n^2\n",
    "    * Critical part is to analysis how the running time of algorithm increase with the size of input in the limit.\n",
    "    \n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "\n",
    "# Asymptotatic Notation:\n",
    "\n",
    "\n",
    "## The \"Big-Oh\" O-notation:\n",
    "\n",
    "The notation Ο(n) is the formal way to express the upper bound of an algorithm's running time. It measures the worst case time complexity or the longest amount of time an algorithm can possibly take to complete.\n",
    "\n",
    "Used for  worst case only.\n",
    "\n",
    "f(n)=O(g(n)),\n",
    "\n",
    "if there exists constant c and n0 (n not) then f(n)  <= cg(n) for n>n0.\n",
    "\n",
    "<img src=\"Big%20O%20Graph.png\",width=200,height=200>\n",
    "\n",
    "**example**:\n",
    "\n",
    "<img src=\"BigOhExample.png\",width=400,height=200>\n",
    "\n",
    "In this example \n",
    "\n",
    "f(n)=2n+6---> O(n)\n",
    "\n",
    "    c1 g(n) < f(n)  < c2 g(n)\n",
    "\n",
    "    1  g(n) < f(n)  < c2 g(n)\n",
    "\n",
    "      n     < 2n+6 < 4n\n",
    "      \n",
    " Use O notation  to express number of primitive operation executed as function of input size.\n",
    " \n",
    " #### Asymptotic Notation (terminology):\n",
    " \n",
    "     * Logarithimic : O(logn)\n",
    "     * Linear       : O(n)\n",
    "     * Quadratic    : O(n^2)\n",
    "     * Polynomial   : O(n^k) k-> constant and k>=1\n",
    "     * Exponential  : O(a^n) a>1\n",
    "     \n",
    "     \n",
    "## The \"Big Omega\" Ω-Notation:\n",
    "\n",
    "Big - Omega notation is used to define the lower bound of an algorithm in terms of Time Complexity.\n",
    "\n",
    "That means Big - Omega notation always indicates the minimum time required by an algorithm for all input values. That means Big - Omega notation describes the best case of an algorithm time complexity.\n",
    "\n",
    "Big - Omega Notation can be defined as follows..\n",
    "\n",
    "Consider function f(n) the time complexity of an algorithm and g(n) is the most significant term. If f(n) >= C x g(n) for all n >= n0, C > 0 and n0 >= 1. Then we can represent f(n) as Ω(g(n)).\n",
    "     \n",
    "<img src=\"Big Omega Graph.png\",width=400,height=200>\n",
    "\n",
    "\n",
    "## The \"Big- Theta\" Notation:\n",
    "\n",
    "Big - Theta notation is used to define the average bound of an algorithm in terms of Time Complexity.\n",
    "\n",
    "That means Big - Theta notation always indicates the average time required by an algorithm for all input values. That means Big - Theta notation describes the average case of an algorithm time complexity.\n",
    "\n",
    "Big - Theta Notation can be defined as follows.\n",
    "\n",
    "Consider function f(n) the time complexity of an algorithm and g(n) is the most significant term. If C1 g(n) <= f(n) >= C2 g(n) for all n >= n0, C1, C2 > 0 and n0 >= 1. Then we can represent f(n) as Θ(g(n)).\n",
    "\n",
    "\n",
    "<img src=\"Big ThetaGraph.png\",width=400,height=200>\n",
    "\n",
    "  \n",
    " "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Javascript (Node.js)",
   "language": "javascript",
   "name": "javascript"
  },
  "language_info": {
   "file_extension": ".js",
   "mimetype": "application/javascript",
   "name": "javascript",
   "version": "6.9.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
